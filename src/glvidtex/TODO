Note: Video Conversion Example:
	for i in `ls .`; do(mencoder $i -ofps 23.976 -oac mp3lame -lameopts abr:br=92 -ovc xvid -xvidencopts bitrate=2000 -o $i-xvid.avi);done;


Target: pixelrevo-player
	Components:
		Core:
			GLWidget / GLDrawable
				Drawable Items:
					GLVideoInputDrawable (done)
						- TODO:
							Crossfading doesnt *quite* work smoothly enough -
							I think this is due to the initaliztion of the V4L subsystem for the second camera - if the V4L input is already open, it *should* crossfade fine....
					GLVideoLoopDrawable (done)
					GLVideoFileDrawable (done)
						- TODO: 
							Add properties for:
								- play/pause/ff/rw/etc
								- Add seek method/slots
								- Query play time for remote controllers
					GLVideoReceiverDrawable (done)
					GLImageDrawable (done)
					GLTextDrawable (done)
						- TODO:
							Add properties for text shadow / color etc
					GLRectDrawable
					GLVideoMjpegDrawable (done)
				Todo Items:
					- (done) Add native cross fading support in GLVideoDrawable (since all items above will probably derive from GLVideoDrawable)
					- (done) Add a 'transmit video' property to Video(input|file) drawables
						- Called it 'videoSenderEnabled' - automatically allocates port if none set explicitly, starting from 7755 and up (tests to see if port is in use.) Port used can be queried from 'videoSenderPort' property, or set using same proprty.
					- Add dropshadow support for image/text/rect
					- Add outline support for image/text/rect/videos
					- Add (explicit?) property animations for GLDrawable rect/opac props
					- Consider adding a GLWebDrawable .. ? (idea: Use the proxy method used in DViz to render using QWebView off screen and feed frames as a video source...?)
					
			Data Structure:
				Schedule
					Each Schedule Entry Specifies a:
						- SceneGroup
							- Scene in that group
								- Layout in that scene
									- Sets the 'user' property on one or more drawables in that scene
									- Set the visibility of an item
						- The duration of that schedule entry can be either:
							- A. Automatically Calculated (Implicit Duration)
								- The longest explicit or implicit duration of the media in every user property set in this Schedule Entry is the automatic/Implicit duration of the schedule entry
								- If this schedule entry is assigned a date/time, and the next entry assigned a datetime is closer than the automatic duration, this entry will only "play" until
								  the next date/time schedule entry is scheduled to "play"
							- B. Manually Set
								- If no implicit duration can be calculated, or the user desires to override the duration, the duration can be manualy set
								- However, the next hard-scheduled (date/time assigned) schedule item to come up will go live, even if this entry still has manually-specified time left to play
						- The date/time the Schedule Entry ("Item") is to play
							- The date/time can be implicit or manual ("locked")
								- If implicit, it will still be assigned a date/time, but only for human reference, based on the cumulative duration of the previously scheduled items added from the last "locked" schedule item
									- Implicit date/timed items will play immediately following the previously playing entry
									- Implicit items will NOT cut into a previously playing item - they will allow the full duration of the previous item to occur
								- Locked date/time items will cut into previously playing items to play when that date/time occurs
						
						- If, when the duration of the item playing is completed, and the next item is a "locked"/manually-set date/time item, and it is not yet that date/time, then the last implicit item following the most recet locked date/time items should play, in essence "looping" until the next "locked" date/time item
						
						- Since the Schedule Entry can specify the user property of even just one item and leave the rest unchanged, a previously playing drawable will retain its existing user property even though another drawables' user prop is scheduled to change, in effect creating overlapping schedule items.
				
				The SchedulePlayer reads the list of ScheduleItems from the active Schedule and implements the required timing logic, honoring implicit/explicit duratiosn and date/times, effecting the property/visibility changes and scenegroup/scene/layout changes as needed
					SchedulePlayer therefore needs the ability to:
						- Locate SceneGroups
							- By 'ID' or File, however they are specified in the schedule
				
				SceneGroup
					- <list of drawables>
					Scene
						- <list of drawables>
						- <list of layouts, one or more>
							- each layout contains a list of properties for each drawable in the Scene
								- rect
								- visible/not visible
								- opacity
								- (other related visual properties)
								- a qvariant 'user' property (for the user controllable property value, such as the image file to show, etc)
								
		
		Playing Functionality:
			- Two things to 'play':
				- inputs for the drawables (videos/images/etc)
				- the entire layout
					- Structure Concept:
						- Scene
							- All the elements as a bulk collection
							- Layout
								- Positions elements, shows/hides elements
			- Need a controller which:
				- loads playlists for each item and for layout
				- syncs changes to clock
				- listens for changes to playlist object and reloads accordingly
				
			- Need playlist object:
				- list of playlist items
					- item:
						- drawableId & propName/value
						- 
						
			
					





Update GLDrawable to either support:
	- Blue Alpha Blending
		- Already supports alpha masks
		- Use the blue channel (or some other channel) to control blending the pixel between BLACK and the texture color
		- This would allow drawing black lines on top of the texture using the alpha mask, instead of requiring a third texture for an overlay (in addition to the alpha mask)
	- Or a third texture for overlay on top of the alpha mask
		
Update VideoThread to support HD
	Need to create a variable length buffer
	Move timing code into buffer control
	Selectivly hold frames if falling behind 
	
	Also, get YUV420P working in raw format to allow YUV conversion on the GPU
