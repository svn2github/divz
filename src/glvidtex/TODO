TODO:
	BUGS:
		- Director: playlist keeps playing after switching slides...?
		- Director: playlist text looses formatting when playing?
		- Director: After closing editor, the slide never re-appears in director view, even after clicking the slide again in the list
		- Editor: Sometimes an item gets "stuck" while "selected" - and no wway to click it and get it to emit a selected signal again even after adding items or clicking other items
		- [FIXED] For some reason, changing lots of subview values (e.g. drag sliders) causes the player to "bog down" - is something not getting deleted properly on player?
		- [CONFIRMED] Make sure that video threads are getting deleted on player when changing videos
		- [DONE] Rewrite VideoFrame and all usages to either inherit from QSharedData or some other pointer class
			Because a race condition seems to develop when two video drawables attempt to use the same video source (such as a CameraThread) - and somehow C++ seems to call the 
			destructor on VideoFrame causing a SIUGSEGV deep in QByteArray
		- When viewing remote using vid send/receiver thru a VideoWidget, one of the video streams seems to 'back up' and only "unspools" when sent live thru a GLVideoDrawable... ???
		
	NEEDED FEATURES:
		- Fade speed control
		- Need to set canvas size of the groups
		- Add 'setup' options to the video switcher to configure the video feed from director
			- Input
			- Should these be part of the editor?
				- Flip
				- BHCS
				- Crop
		[DONE] - VideoSender/Receiver needs to be able to degrade quality over network to reduce bandwidth, reduce latency, and increase fps to ~10fps minimum
			[DONE] - Reduce transmission fps to minimum (10)
			[DONE] - Scale image down for transmission 
		- Either (a) integrate with DViz songs.db and Bible functionality or (b) integrate VideoSender with DViz
		- Border/Dropshadow control for items
			- Right now, text and images
		- Black button
	
	IDEAS:
		- Text scroller
			- Renders a playlist of text items 
			- Calc the current # of items to fill the screen layed out H or V, then render that many + 1 as a QImage
				- Use QImage::copy() to render a moving rectangle
				- When one item falls off the "left", re-render
		- HTML snippet widget
			- Embed a QWebKit widget's output for view-only content
		- Store pixmaps/images of scenes, groups, and drawables in the GLScene/GLSceneGroup/GLDrawable for rendering as icon in the appros list models
		- Get layouts working
		- Integrate with the three most used "generators" from DViz:
			- Bible
			- Songs
			- Image Slideshows
			- Each generates a GLSceneGroup containing multiple GLScenes with appros GLDrawables to represent the content
		- Add item layout helpers to editor
			[DONE] - Center H/V
			[DONE] - Text autofit
			- Item autofit 
		- Add copy/paste
		
		
		

TARGET DATE: 12/11 9am
	Features Required by 12/11 9am:
		[DONE] - Network Control of a player binary
		- Player Binary must:
			- Load scene groups and play the required group/scene/layout on demand over network
				- TASKS:
					[DONE] Create a GLPlayerServer class, feature bullets:
						Listen on a port
						Accept data "frames", similar to the way the VideoReceiver accepts input (header + data block)
							Data block is a byte array for a QVariantMap
							Required Map Keys:
								- Sequence # (auto incremented number)
								- Command (e.g. loadSlideGroup, etc. - compile a list of valid comments)
								- QVariantMap is passed enmass as a ref (&) to the command
								- Command should be a slot that accepts a QVariantMap 
							Think of commands as slot calls
						Responds to conected client ala a signal
							GLPlayerServer should have a slot that can be called with a QVariantMap 
								One of the keys should be a "responseName"
								The client should function like the server, responses are slots that accept a QVariantMap
					[DONE] Create command slots for the GLPlayerServer class:
						- Functions needed:
							[TODO] - SetBlackout
								- Black out the output 
							- LoadSlideGroup
								- Only one slide group is "Active" in the player at once
								- Dont add items if items not in the viewport
							- SetSlide
								- Set the slide by ID
							[TODO - implement layouts] - SetLayout
								- Set the layout on the slide by ID
							- SetUserProperty
								- Set the user prop on a GLDrawable by drawable ID
							- SetVisibility
								- Set visiblility flag on a drawable by ID
							[TODO] - DownloadFile
								- Transmit a file from the controller to the player over the network so it can be loaded
								- Need to adjust the file-based classes to load files from the "network download" location if not on disk
									- GLImageDrawable
									- GLVideoLoopDrawable
									- GLVideoFileDrawable
									- Others?
							- QueryProperty
								- Query a Q_PROPERTY on a drawable by drawable ID & property name
								- Response is emitted as a "signal" (see above)
							- QuerySlide
							- QueryLayout
								- Query the active slide/layout
								- Response is emitted as a "signal" (see above)
							- SetAlphaMask
							- SetKeystone
							- SetWindow
							- SetFlip
							- SetIgnoreAR
							- SetViewport
							- SetCanvasSize
							- SetBCHS
								- The above set various player parameters ala the INI file reading in the PlayerWindow.cpp class
								- Provide corresponding query methods to read those player parameters back
							[TODO] - FUTURE:
								- Add commands to set up system (OS) methods such as 
									Time/Date
									IP Address
									Users/Passwords
									etc
					[TODO] Add properties to GLTextDrawable for the text color/outlines/etc
					
						
			[DONE] - Set visibility/user props over network on demand
			[DONE] - IF TIME: Send back video
			[DONE] - IF TIME: Run playlists
		- Director Screen
			[DONE] - TASKS:
				- Create GLPlayerClient class
					- Client half of the server above
					- Sends command packets
					- Accepts incoming response packets
			- Must connect to more than one player for control
				- For target date, we need at least two players:
					- FoH (front of house, cloned output or double wide - not sure yet)
					- Wash (player with double-wide canvas for output to two projectors)
			[DONE] - Player Setup UI:
				- Player "Code"/Title
				- IP Address/Port
				- Alpha Mask
					- Paintbrush-esque UI with simple rects/polygons....???
				- Keystoning
				- Window Pos/Size
				- Flip H/V
				- Ignore AR
				- Viewport/Canvas (loaded from slide group...)
				- BCHS Adjustments
				- Control Option:
					- Control player individually
						- UI will display player with List UI(below) in a "tab" ala firefox webpage
					- Combined Player Control 
						- Viewport rectangle selection
						
				- TASKS:
					[DONE] - Create UI for this setup screen in designer
					[DONE] - Create a simple widget for keystoning
						- Widget displays a rectangle with four corners that are draggable
						- Sends keystoning coordinates to player in real time
						- Be sure to provide numerical inputs below the widget for manual entry of keystone values
					[DONE] - IMPORTANT:
						- Try to integrate the cvFindPlanarHomagraphy function
					[DONE] - Create data structure to store player settings
						- Some sort of orm class
						- From/To bytearray
						- PlayerList class
							- Derive from a AbstractITemList
							- Write/Load from byte array
							- Save to QSettings?
			[DONE] - List UI:
				[DONE] - 1. List of slide groups available
				[DONE] - 2. List of slides in selected slide group
				[DONE] - 3. List of layouts in selected slide (selecting slide goes live)
				[DONE] - 4. List of user-conrollable items on current slide/layout
				[DONE] - 5. Panel for:
					- Top: Layouts
					- Mid: Live area
					- Lower: Left: List of items, right: Top: Visible btn, Bottom: Value input
			[TODO] - Black/unblack Master UI btn
			[DONE] - All players get the live slide, Editor indexes viewports by player 
				- E.g.  Player "FOH"  viewport (0,0)-(2048x768)
					Player "Wash" viewport (0,1024)-(2048x768)
				So canvas would be 2048x1536, with 1024x768 quads for each projector
		[DONE] - Editor Screen
			[DONE] - Edit one slidegroup at a time
			[DONE] - List of slides on left
			[*TODO*] - List of key frames on top
				- Horizontal row of icons
				- Always a blank icon on the right to edit
				- Always editing the currently-selected icon
			[DONE] - Main editing area in center
			[DONE] - Toolbar for adding items
			[DONE] - Setup canvas size
			[DONE] - Property editor on right to change the main property 
			
			- TASKS:
				- [DONE] Add AbstractListModel methods to the GLSceneGroup and GLScene classes
				[DONE] - Add a user property flag to GLDrawables
				[DONE] - Create property editor panels based on the old livelayer work
				[DONE] - Create UI in Qt Creator
				[DONE] - Create GLSceneGroupCollection as a meta-group of scenes
					- [DONE] From/to byte array methods
					- [DONE] Write/read from file
					- [DONE] Index scene groups by ID as well
					- Add a "editSequence" value to collection->group->scene classes for tracking edits and when to re-transmit changed slides
				
		[DONE] - Need a document type containing multiple slide groups
		- Need to consider not sending GLDrawables/slides to players that dont need them



Note: Video Conversion Example:
	for i in `ls .`; do(mencoder $i -ofps 23.976 -oac mp3lame -lameopts abr:br=92 -ovc xvid -xvidencopts bitrate=2000 -o $i-xvid.avi);done;


Target: pixelrevo-player
	Components:
		Core:
			GLWidget / GLDrawable
				Drawable Items:
					GLVideoInputDrawable (done)
						- TODO:
							Crossfading doesnt *quite* work smoothly enough -
							I think this is due to the initaliztion of the V4L subsystem for the second camera - if the V4L input is already open, it *should* crossfade fine....
					GLVideoLoopDrawable (done)
					GLVideoFileDrawable (done)
						- TODO: 
							Add properties for:
								- play/pause/ff/rw/etc
								- Add seek method/slots
								- Query play time for remote controllers
					GLVideoReceiverDrawable (done)
					GLImageDrawable (done)
					GLTextDrawable (done)
						- TODO:
							Add properties for text shadow / color etc
					GLRectDrawable
					GLVideoMjpegDrawable (done)
				Todo Items:
					- (done) Add native cross fading support in GLVideoDrawable (since all items above will probably derive from GLVideoDrawable)
					- (done) Add a 'transmit video' property to Video(input|file) drawables
						- Called it 'videoSenderEnabled' - automatically allocates port if none set explicitly, starting from 7755 and up (tests to see if port is in use.) Port used can be queried from 'videoSenderPort' property, or set using same proprty.
					- Add dropshadow support for image/text/rect
					- Add outline support for image/text/rect/videos
					- Add (explicit?) property animations for GLDrawable rect/opac props
					- Consider adding a GLWebDrawable .. ? (idea: Use the proxy method used in DViz to render using QWebView off screen and feed frames as a video source...?)
					
			Data Structure:
				Schedule
					Each Schedule Entry Specifies a:
						- SceneGroup
							- Scene in that group
								- Layout in that scene
									- Sets the 'user' property on one or more drawables in that scene
									- Set the visibility of an item
						- The duration of that schedule entry can be either:
							- A. Automatically Calculated (Implicit Duration)
								- The longest explicit or implicit duration of the media in every user property set in this Schedule Entry is the automatic/Implicit duration of the schedule entry
								- If this schedule entry is assigned a date/time, and the next entry assigned a datetime is closer than the automatic duration, this entry will only "play" until
								  the next date/time schedule entry is scheduled to "play"
							- B. Manually Set
								- If no implicit duration can be calculated, or the user desires to override the duration, the duration can be manualy set
								- However, the next hard-scheduled (date/time assigned) schedule item to come up will go live, even if this entry still has manually-specified time left to play
						- The date/time the Schedule Entry ("Item") is to play
							- The date/time can be implicit or manual ("locked")
								- If implicit, it will still be assigned a date/time, but only for human reference, based on the cumulative duration of the previously scheduled items added from the last "locked" schedule item
									- Implicit date/timed items will play immediately following the previously playing entry
									- Implicit items will NOT cut into a previously playing item - they will allow the full duration of the previous item to occur
								- Locked date/time items will cut into previously playing items to play when that date/time occurs
						
						- If, when the duration of the item playing is completed, and the next item is a "locked"/manually-set date/time item, and it is not yet that date/time, then the last implicit item following the most recet locked date/time items should play, in essence "looping" until the next "locked" date/time item
						
						- Since the Schedule Entry can specify the user property of even just one item and leave the rest unchanged, a previously playing drawable will retain its existing user property even though another drawables' user prop is scheduled to change, in effect creating overlapping schedule items.
				
				The SchedulePlayer reads the list of ScheduleItems from the active Schedule and implements the required timing logic, honoring implicit/explicit duratiosn and date/times, effecting the property/visibility changes and scenegroup/scene/layout changes as needed
					SchedulePlayer therefore needs the ability to:
						- Locate SceneGroups
							- By 'ID' or File, however they are specified in the schedule
				
				SceneGroup
					- <list of drawables>
					Scene
						- <list of drawables>
						- <list of layouts, one or more>
							- each layout contains a list of properties for each drawable in the Scene
								- rect
								- visible/not visible
								- opacity
								- (other related visual properties)
								- a qvariant 'user' property (for the user controllable property value, such as the image file to show, etc)
								
		
		Playing Functionality:
			- Two things to 'play':
				- inputs for the drawables (videos/images/etc)
				- the entire layout
					- Structure Concept:
						- Scene
							- All the elements as a bulk collection
							- Layout
								- Positions elements, shows/hides elements
			- Need a controller which:
				- loads playlists for each item and for layout
				- syncs changes to clock
				- listens for changes to playlist object and reloads accordingly
				
			- Need playlist object:
				- list of playlist items
					- item:
						- drawableId & propName/value
						- 
						
			
					





Update GLDrawable to either support:
	- Blue Alpha Blending
		- Already supports alpha masks
		- Use the blue channel (or some other channel) to control blending the pixel between BLACK and the texture color
		- This would allow drawing black lines on top of the texture using the alpha mask, instead of requiring a third texture for an overlay (in addition to the alpha mask)
	- Or a third texture for overlay on top of the alpha mask
		
Update VideoThread to support HD
	Need to create a variable length buffer
	Move timing code into buffer control
	Selectivly hold frames if falling behind 
	
	Also, get YUV420P working in raw format to allow YUV conversion on the GPU
